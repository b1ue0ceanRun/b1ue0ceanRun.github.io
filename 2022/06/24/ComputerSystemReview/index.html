<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 5.4.1">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.0.0/css/all.min.css" integrity="sha256-jTIdiMuX/e3DGJUGwl3pKSxuc6YOuqtJYkM0bGQESA4=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.10.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":{"gitalk":{"order":-2}}},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"},"path":"/search.xml","localsearch":{"enable":"ture","trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>

    <meta name="description" content="期末复习 小总结一下  看到有人把这门课学&#x2F;搞成一门背书的课 是真的sb">
<meta property="og:type" content="article">
<meta property="og:title" content="操作系统期末复习">
<meta property="og:url" content="http://example.com/2022/06/24/ComputerSystemReview/index.html">
<meta property="og:site_name" content="b1ue0cean&#39;s   blog">
<meta property="og:description" content="期末复习 小总结一下  看到有人把这门课学&#x2F;搞成一门背书的课 是真的sb">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://example.com/2022/06/24/ComputerSystemReview/image-20220624111549062.png">
<meta property="og:image" content="http://example.com/2022/06/24/ComputerSystemReview/image-20220624112059223.png">
<meta property="og:image" content="http://example.com/2022/06/24/ComputerSystemReview/image-20220624113555335.png">
<meta property="og:image" content="http://example.com/2022/06/24/ComputerSystemReview/image-20220624114101242.png">
<meta property="og:image" content="http://example.com/2022/06/24/ComputerSystemReview/image-20220624114459582.png">
<meta property="og:image" content="http://example.com/2022/06/24/ComputerSystemReview/image-20220624120920676.png">
<meta property="og:image" content="http://example.com/2022/06/24/ComputerSystemReview/image-20220624144507975.png">
<meta property="og:image" content="http://example.com/2022/06/24/ComputerSystemReview/image-20220624173741835.png">
<meta property="og:image" content="http://example.com/2022/06/24/ComputerSystemReview/image-20220624144803020.png">
<meta property="og:image" content="http://example.com/2022/06/24/ComputerSystemReview/image-20220624155406128.png">
<meta property="og:image" content="http://example.com/2022/06/24/ComputerSystemReview/image-20220624162641093.png">
<meta property="og:image" content="http://example.com/2022/06/24/ComputerSystemReview/image-20220624162912940.png">
<meta property="og:image" content="http://example.com/2022/06/24/ComputerSystemReview/image-20220624163532078.png">
<meta property="og:image" content="http://example.com/2022/06/24/ComputerSystemReview/format,png-16560607633459.png">
<meta property="og:image" content="http://example.com/2022/06/24/ComputerSystemReview/image-20220624164041655.png">
<meta property="og:image" content="http://example.com/2022/06/24/ComputerSystemReview/format,png.png">
<meta property="og:image" content="http://example.com/2022/06/24/ComputerSystemReview/format,png-16560603644473.png">
<meta property="og:image" content="http://example.com/2022/06/24/ComputerSystemReview/format,png-16560604573506.png">
<meta property="og:image" content="http://example.com/2022/06/24/ComputerSystemReview/format,png-165606084954512.png">
<meta property="og:image" content="http://example.com/2022/06/24/ComputerSystemReview/format,png-165606086771215.png">
<meta property="og:image" content="http://example.com/2022/06/24/ComputerSystemReview/format,png-165606094777021.png">
<meta property="og:image" content="http://example.com/2022/06/24/ComputerSystemReview/format,png-165606093371718.png">
<meta property="og:image" content="http://example.com/2022/06/24/ComputerSystemReview/format,png-165606095883624.png">
<meta property="og:image" content="http://example.com/2022/06/24/ComputerSystemReview/format,png-165606096579827.png">
<meta property="og:image" content="http://example.com/2022/06/24/ComputerSystemReview/format,png-165606097362530.png">
<meta property="article:published_time" content="2022-06-24T02:44:56.000Z">
<meta property="article:modified_time" content="2022-10-06T03:54:34.865Z">
<meta property="article:author" content="b1ue0cean">
<meta property="article:tag" content="review">
<meta property="article:tag" content="Computer System">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/2022/06/24/ComputerSystemReview/image-20220624111549062.png">


<link rel="canonical" href="http://example.com/2022/06/24/ComputerSystemReview/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"en","comments":true,"permalink":"http://example.com/2022/06/24/ComputerSystemReview/","path":"2022/06/24/ComputerSystemReview/","title":"操作系统期末复习"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>操作系统期末复习 | b1ue0cean's   blog</title>
  





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
<link rel="alternate" href="/atom.xml" title="b1ue0cean's   blog" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">b1ue0cean's   blog</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">welcome to my world -- sharing CTF & ML skills</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home"><a href="/" rel="section">Home</a></li>
        <li class="menu-item menu-item-about"><a href="/about/" rel="section">About</a></li>
        <li class="menu-item menu-item-tags"><a href="/tags/" rel="section">Tags<span class="badge">156</span></a></li>
        <li class="menu-item menu-item-categories"><a href="/categories/" rel="section">Categories<span class="badge">54</span></a></li>
        <li class="menu-item menu-item-archives"><a href="/archives/" rel="section">Archives<span class="badge">200</span></a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#OS-%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E5%8F%8A%E4%B8%BB%E8%A6%81%E7%89%B9%E7%82%B9"><span class="nav-number">1.</span> <span class="nav-text">OS 基本类型及主要特点</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%89%B9%E5%A4%84%E7%90%86%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F"><span class="nav-number">1.1.</span> <span class="nav-text">批处理操作系统</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%86%E6%97%B6%E7%B3%BB%E7%BB%9F"><span class="nav-number">1.2.</span> <span class="nav-text">分时系统</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9E%E6%97%B6%E7%B3%BB%E7%BB%9F"><span class="nav-number">1.3.</span> <span class="nav-text">实时系统</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%8E%B0%E4%BB%A3%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E4%B8%BB%E8%A6%81%E7%89%B9%E5%BE%81"><span class="nav-number">2.</span> <span class="nav-text">现代操作系统的主要特征</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B9%B6%E5%8F%91"><span class="nav-number">2.1.</span> <span class="nav-text">并发</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B1%E4%BA%AB"><span class="nav-number">2.2.</span> <span class="nav-text">共享</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%82%E6%AD%A5"><span class="nav-number">2.3.</span> <span class="nav-text">异步</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%99%9A%E6%8B%9F"><span class="nav-number">2.4.</span> <span class="nav-text">虚拟</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E4%B8%89%E7%A7%8D%E5%9F%BA%E6%9C%AC%E7%8A%B6%E6%80%81%E5%8F%8A%E8%BD%AC%E6%8D%A2%E5%85%B3%E7%B3%BB"><span class="nav-number">3.</span> <span class="nav-text">进程的三种基本状态及转换关系</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E6%AD%BB%E9%94%81%E7%9A%84%E5%9B%9B%E4%B8%AA%E5%BF%85%E8%A6%81%E6%9D%A1%E4%BB%B6"><span class="nav-number">4.</span> <span class="nav-text">进程死锁的四个必要条件</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%AD%BB%E9%94%81%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="nav-number">4.1.</span> <span class="nav-text">死锁的定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%8F%E5%85%B8IPC%E9%97%AE%E9%A2%98%E7%9A%84%E4%B8%A4%E4%B8%AA%E5%AE%9E%E4%BE%8B-%E4%B8%8D%E8%A6%81%E6%B1%82%E6%8E%8C%E6%8F%A1"><span class="nav-number">4.2.</span> <span class="nav-text">经典IPC问题的两个实例(不要求掌握)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AF%BB%E8%80%85%E2%80%93%E5%86%99%E8%80%85%E9%97%AE%E9%A2%98"><span class="nav-number">4.2.1.</span> <span class="nav-text">读者–写者问题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%93%B2%E5%AD%A6%E5%AE%B6%E5%B0%B1%E9%A4%90%E9%97%AE%E9%A2%98"><span class="nav-number">4.2.2.</span> <span class="nav-text">哲学家就餐问题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%A7%E7%94%9F%E6%AD%BB%E9%94%81%E7%9A%844%E4%B8%AA%E5%BF%85%E8%A6%81%E6%9D%A1%E4%BB%B6"><span class="nav-number">4.3.</span> <span class="nav-text">产生死锁的4个必要条件</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%89%E5%85%A8%E7%8A%B6%E6%80%81%E7%9A%84%E5%88%A4%E6%96%AD%E3%80%81%E9%93%B6%E8%A1%8C%E5%AE%B6%E7%AE%97%E6%B3%95%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="nav-number">5.</span> <span class="nav-text">安全状态的判断、银行家算法的概念</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8E%9F%E8%AF%AD%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="nav-number">6.</span> <span class="nav-text">原语的概念</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E5%9F%BA%E6%9C%AC%E7%AE%97%E6%B3%95-FCFS%EF%BC%8CRR%EF%BC%8C%E4%BC%98%E5%85%88%E7%BA%A7-%E7%9A%84%E6%80%9D%E6%83%B3"><span class="nav-number">7.</span> <span class="nav-text">进程调度基本算法[FCFS，RR，优先级]的思想</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%88%E6%9D%A5%E5%85%88%E6%9C%8D%E5%8A%A1%EF%BC%88FCFS%EF%BC%8CFirst-Come-First-Serve-%EF%BC%89"><span class="nav-number">7.1.</span> <span class="nav-text">先来先服务（FCFS，First Come First  Serve ）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BD%AE%E8%BD%AC%E6%B3%95%EF%BC%88RR%EF%BC%8Cround-robin%EF%BC%89"><span class="nav-number">7.2.</span> <span class="nav-text">轮转法（RR，round robin）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BC%98%E5%85%88%E7%BA%A7%E6%B3%95"><span class="nav-number">7.3.</span> <span class="nav-text">优先级法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%90%8C%E6%AD%A5%E4%B8%8E%E4%BA%92%E6%96%A5%E7%9A%84%E6%A6%82%E5%BF%B5%EF%BC%8C%E4%BB%A5%E5%8F%8A%E7%94%9F%E4%BA%A7%E8%80%85-%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%9E%8B%E7%9A%84%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1"><span class="nav-number">8.</span> <span class="nav-text">同步与互斥的概念，以及生产者-消费者模型的并发控制程序设计</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%B4%E7%95%8C%E8%B5%84%E6%BA%90%E4%B8%8E%E4%B8%B4%E7%95%8C%E5%8C%BA"><span class="nav-number">8.1.</span> <span class="nav-text">临界资源与临界区</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E4%BA%92%E6%96%A5"><span class="nav-number">8.2.</span> <span class="nav-text">进程互斥</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#P%E3%80%81V%E6%93%8D%E4%BD%9C"><span class="nav-number">8.3.</span> <span class="nav-text">P、V操作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%94%A8%E4%BF%A1%E5%8F%B7%E9%87%8F%E8%A7%A3%E5%86%B3%E7%94%9F%E4%BA%A7%E8%80%85-%E6%B6%88%E8%B4%B9%E8%80%85%E9%97%AE%E9%A2%98"><span class="nav-number">8.4.</span> <span class="nav-text">用信号量解决生产者-消费者问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5%E6%A6%82%E5%BF%B5"><span class="nav-number">8.5.</span> <span class="nav-text">进程同步概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%94%A8PV%E6%93%8D%E4%BD%9C%E5%AE%9E%E7%8E%B0%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5"><span class="nav-number">8.6.</span> <span class="nav-text">用PV操作实现进程同步</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86%E4%B8%AD%E9%87%8D%E5%AE%9A%E4%BD%8D%E7%9A%84%E6%A6%82%E5%BF%B5%E5%8F%8A%E5%85%B6%E6%96%B9%E5%BC%8F"><span class="nav-number">9.</span> <span class="nav-text">存储管理中重定位的概念及其方式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%BB%E8%BE%91%E5%9C%B0%E5%9D%80%EF%BC%88%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%EF%BC%89"><span class="nav-number">9.1.</span> <span class="nav-text">逻辑地址（虚拟地址）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%89%A9%E7%90%86%E5%9C%B0%E5%9D%80%EF%BC%88%E7%BB%9D%E5%AF%B9%E5%9C%B0%E5%9D%80%EF%BC%89"><span class="nav-number">9.2.</span> <span class="nav-text">物理地址（绝对地址）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%BB%E8%BE%91%E5%9C%B0%E5%9D%80%E4%B8%8E%E7%89%A9%E7%90%86%E5%9C%B0%E5%9D%80%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="nav-number">9.3.</span> <span class="nav-text">逻辑地址与物理地址的关系</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9C%B0%E5%9D%80%E5%8F%98%E6%8D%A2"><span class="nav-number">9.4.</span> <span class="nav-text">地址变换</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AF%B7%E6%B1%82%E9%A1%B5%E5%BC%8F%E7%AE%A1%E7%90%86%E7%9A%84%E5%9C%B0%E5%9D%80%E9%87%8D%E5%AE%9A%E4%BD%8D%E8%BF%87%E7%A8%8B%EF%BC%88%E8%AE%A1%E7%AE%97%EF%BC%89%E6%9C%AA%E6%80%BB%E7%BB%93%E5%AE%8C"><span class="nav-number">10.</span> <span class="nav-text">请求页式管理的地址重定位过程（计算）未总结完</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98"><span class="nav-number">10.1.</span> <span class="nav-text">虚拟内存</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%86%E9%A1%B5"><span class="nav-number">10.2.</span> <span class="nav-text">分页</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A1%B5%E6%A1%86"><span class="nav-number">10.3.</span> <span class="nav-text">页框</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A1%B5%E8%A1%A8"><span class="nav-number">10.4.</span> <span class="nav-text">页表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%A1%E7%AE%97"><span class="nav-number">10.5.</span> <span class="nav-text">计算</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%99%9A%E6%8B%9F-%E8%AF%B7%E6%B1%82-%E9%A1%B5%E5%BC%8F%E7%AE%A1%E7%90%86"><span class="nav-number">10.6.</span> <span class="nav-text">虚拟(请求)页式管理</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86%E4%B8%AD%E7%A2%8E%E7%89%87%E7%9A%84%E6%A6%82%E5%BF%B5%EF%BC%8C%E5%8F%8A%E4%B8%8D%E5%90%8C%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86%E6%96%B9%E6%B3%95%E5%87%BA%E7%8E%B0%E7%9A%84%E7%A2%8E%E7%89%87%E9%97%AE%E9%A2%98"><span class="nav-number">11.</span> <span class="nav-text">存储管理中碎片的概念，及不同存储管理方法出现的碎片问题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A2%8E%E7%89%87"><span class="nav-number">11.1.</span> <span class="nav-text">碎片</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%AE%B5%E9%A1%B5%E5%BC%8F%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%8F%8A%E9%87%8D%E5%AE%9A%E4%BD%8D%E8%BF%87%E7%A8%8B%EF%BC%88%E6%A6%82%E5%BF%B5%EF%BC%89"><span class="nav-number">12.</span> <span class="nav-text">段页式存储管理的数据结构及重定位过程（概念）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E5%88%86%E6%AE%B5"><span class="nav-number">12.1.</span> <span class="nav-text">内存分段</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%AE%B5%E9%A1%B5%E5%BC%8F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="nav-number">12.2.</span> <span class="nav-text">段页式内存管理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Linux-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="nav-number">12.3.</span> <span class="nav-text">Linux 内存管理</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%A1%B5%E6%A1%86%E8%B0%83%E5%BA%A6%E7%9A%84%E6%A6%82%E5%BF%B5%EF%BC%8C%E6%8A%96%E5%8A%A8%E7%8E%B0%E8%B1%A1%E5%8F%8A%E5%85%B6%E5%8F%AF%E8%83%BD%E7%9A%84%E5%9B%A0%E7%B4%A0"><span class="nav-number">13.</span> <span class="nav-text">页框调度的概念，抖动现象及其可能的因素</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A1%B5%E6%A1%86%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95%EF%BC%88%E9%A1%B5%E6%A1%86%E8%B0%83%E5%BA%A6%EF%BC%89"><span class="nav-number">13.1.</span> <span class="nav-text">页框置换算法（页框调度）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A2%A0%E7%B0%B8%EF%BC%88%E6%8A%96%E5%8A%A8%EF%BC%89%EF%BC%9A"><span class="nav-number">13.2.</span> <span class="nav-text">颠簸（抖动）：</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E9%80%BB%E8%BE%91%E7%BB%93%E6%9E%84%E3%80%81%E6%96%87%E4%BB%B6%E7%89%A9%E7%90%86%E7%BB%93%E6%9E%84%E7%9A%84%E6%A6%82%E5%BF%B5%E5%8F%8A%E5%88%86%E7%B1%BB%EF%BC%88%E7%89%B9%E7%82%B9%EF%BC%89"><span class="nav-number">14.</span> <span class="nav-text">文件逻辑结构、文件物理结构的概念及分类（特点）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%BB%E8%BE%91%E7%BB%93%E6%9E%84%EF%BC%88%E9%80%BB%E8%BE%91%E6%96%87%E4%BB%B6%EF%BC%89"><span class="nav-number">14.1.</span> <span class="nav-text">逻辑结构（逻辑文件）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%89%A9%E7%90%86%E7%BB%93%E6%9E%84%EF%BC%88%E7%89%A9%E7%90%86%E6%96%87%E4%BB%B6%EF%BC%89"><span class="nav-number">14.2.</span> <span class="nav-text">物理结构（物理文件）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#I-O-%E6%8E%A7%E5%88%B6%E6%96%B9%E5%BC%8F%E7%9A%84%E7%B1%BB%E5%9E%8B%E5%8F%8A%E7%89%B9%E7%82%B9"><span class="nav-number">15.</span> <span class="nav-text">I&#x2F;O 控制方式的类型及特点</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E7%A8%8B%E5%BA%8F%E7%9B%B4%E6%8E%A5%E6%8E%A7%E5%88%B6%E6%96%B9%E5%BC%8F"><span class="nav-number">15.1.</span> <span class="nav-text">(1) 程序直接控制方式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E4%B8%AD%E6%96%AD%E6%8E%A7%E5%88%B6%E6%96%B9%E5%BC%8F"><span class="nav-number">15.2.</span> <span class="nav-text">**(2) 中断控制方式 **</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-DMA%E6%96%B9%E5%BC%8F%EF%BC%88Direct-Memory-Access%EF%BC%89"><span class="nav-number">15.3.</span> <span class="nav-text">(3) DMA方式（Direct Memory Access）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-%E9%80%9A%E9%81%93%E6%96%B9%E5%BC%8F"><span class="nav-number">15.4.</span> <span class="nav-text">(4) 通道方式</span></a></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="b1ue0cean"
      src="/uploads/avatar.jpeg">
  <p class="site-author-name" itemprop="name">b1ue0cean</p>
  <div class="site-description" itemprop="description">我就是我，人间不一样的烟火</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">200</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">54</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">156</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://github.com/godrun666" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;godrun666" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:1019076587@qq.com" title="E-Mail → mailto:1019076587@qq.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://twitter.com/b1ue0cean7" title="Twitter → https:&#x2F;&#x2F;twitter.com&#x2F;b1ue0cean7" rel="noopener" target="_blank"><i class="fab fa-twitter fa-fw"></i>Twitter</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://blog.csdn.net/qq_53755216" title="CSDN → https:&#x2F;&#x2F;blog.csdn.net&#x2F;qq_53755216" rel="noopener" target="_blank">CSDN</a>
      </span>
  </div>
  <div class="cc-license site-overview-item animated" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" rel="noopener" target="_blank"><img src="https://cdn.jsdelivr.net/npm/@creativecommons/vocabulary@2020.11.3/assets/license_badges/small/by_nc_sa.svg" alt="Creative Commons"></a>
  </div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/06/24/ComputerSystemReview/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/avatar.jpeg">
      <meta itemprop="name" content="b1ue0cean">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="b1ue0cean's   blog">
      <meta itemprop="description" content="我就是我，人间不一样的烟火">
    </span>
    
    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="操作系统期末复习 | b1ue0cean's   blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          操作系统期末复习
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2022-06-24 10:44:56" itemprop="dateCreated datePublished" datetime="2022-06-24T10:44:56+08:00">2022-06-24</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2022-10-06 11:54:34" itemprop="dateModified" datetime="2022-10-06T11:54:34+08:00">2022-10-06</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" itemprop="url" rel="index"><span itemprop="name">操作系统</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <p>期末复习 小总结一下  看到有人把这门课学/搞成一门背书的课 是真的sb</p>
<span id="more"></span>

<h2 id="OS-基本类型及主要特点"><a href="#OS-基本类型及主要特点" class="headerlink" title="OS 基本类型及主要特点"></a>OS 基本类型及主要特点</h2><h3 id="批处理操作系统"><a href="#批处理操作系统" class="headerlink" title="批处理操作系统"></a>批处理操作系统</h3><p><strong>主要特征</strong>： </p>
<ol>
<li>用户脱机使用计算机。 </li>
<li>自动成批处理。（后备作业） </li>
<li>单/多道程序运行。 </li>
</ol>
<p><strong>优点</strong>：资源利用率高，系统吞吐量大。 </p>
<p><strong>缺点</strong>：作业周转时间长，交互能力差</p>
<h3 id="分时系统"><a href="#分时系统" class="headerlink" title="分时系统"></a>分时系统</h3><p>分时系统采用时间片轮转方式，多个用户服务。</p>
<p><strong>特点</strong>： </p>
<ol>
<li><strong>交互性</strong>：用户可以动态提交与控制程 序运行，交互性好。</li>
<li><strong>多路性</strong>：多个用户同时共享一个计算机，充分发挥系统的效率。 </li>
<li><strong>独立性</strong>：多个用户相互独立，如同自 己独占计算机一样。</li>
</ol>
<h3 id="实时系统"><a href="#实时系统" class="headerlink" title="实时系统"></a><strong>实时系统</strong></h3><p>实时系统用于实时控制和实时信息处理领域中。</p>
<p><strong>主要特点</strong>： </p>
<ol>
<li>即时响应：保证在控制对象要求的严 格时间内做出响应。（非用户） </li>
<li>高可靠性：系统本身要安全可靠。 实时系统往往具有一定的专用性，因此系 统资源利用率可能较低。</li>
</ol>
<h2 id="现代操作系统的主要特征"><a href="#现代操作系统的主要特征" class="headerlink" title="现代操作系统的主要特征"></a>现代操作系统的主要特征</h2><p>操作系统的四个基本特征：<strong>并发，共享，异步，虚拟</strong></p>
<h3 id="并发"><a href="#并发" class="headerlink" title="并发"></a><strong>并发</strong></h3><p><strong>是指两个或多个事件在同一时间间隔内发生</strong>。操作系统的并发性是指计算机系统中同时存在多个运行着的程序，因此它应该具有处理和调度多个程序同时执行的能力。在这种多道程序环境下，一段时间内，<strong>宏观上有多个程序在同时运行</strong>，而每一时刻，单处理器环境下实际仅能有一道程序执行，故<strong>微观上这些程序还是在分时地交替执行</strong>。操作系统的<strong>并发性是通过分时得以实现的</strong>。采用并发技术的系统又称为<strong>多任务系统 （multitasking system）</strong></p>
<p>PS: <strong>并发和并行的区别</strong>（并行是指计算机系统具有可以<strong>同时进行运算或操作的特性</strong>，<strong>在同一时间完成两种或两种以上的工作</strong>。并行性<strong>需要有相关硬件的支持</strong>，如多流水线或多处理器硬件环境）。</p>
<h3 id="共享"><a href="#共享" class="headerlink" title="共享"></a><strong>共享</strong></h3><p>是指系统中的资源（硬件资源和信息资源）可以被多个并发执行的程序共同使用，而不是被其中一个独占。资源共享有两种方式：<strong>互斥访问</strong>和<strong>同时访问</strong>。</p>
<p><strong>共享性和并发性是现代操作系统两个最基本的特性，互为依存</strong></p>
<h3 id="异步"><a href="#异步" class="headerlink" title="异步"></a><strong>异步</strong></h3><p>在多道程序环境下，允许多个程序并发执行，但由于资源有限，进程的执行不是一贯到底。而是走走停停，以不可预知的速度向前推进，这就是进程的异步性。</p>
<p>并发性和异步性可能导致程序产生与时间有关的错误。 （举个例子？？） </p>
<p>归根到底是并发进程访问共享变量的事，当多个进程访问共享变量的过程中，就有可能会产生与时间有关的错误，或者是死锁 – 与数据库中需要锁一个道理</p>
<p>操作系统允许出现这样的错误？？</p>
<p>解决方法：PV操作</p>
<h3 id="虚拟"><a href="#虚拟" class="headerlink" title="虚拟"></a><strong>虚拟</strong></h3><p>虚拟性是一种管理技术，把物理上的一个实体变成逻辑上的多个对应物，或把物理上的多个实体变成逻辑上的一个对应物的技术。采用虚拟技术的目的是为用户提供易于使用、方便高效的操作环境</p>
<p>如：打印机、文件等都采用了虚拟技术。 采用虚拟技术的目的是：<strong>友好的接口和提高资源利用率</strong></p>
<h2 id="进程的三种基本状态及转换关系"><a href="#进程的三种基本状态及转换关系" class="headerlink" title="进程的三种基本状态及转换关系"></a>进程的三种基本状态及转换关系</h2><ol>
<li><strong>运行态</strong>running：正在占有处理器运行。  </li>
<li><strong>就绪态</strong>ready：具备运行条件，但由于无 CPU暂时不能运行的状态</li>
<li><strong>等待态</strong>wait：阻塞（blocked）态、睡眠 （sleep）态，因等待某种事件的发生而暂时不能运行的状态。</li>
</ol>
<p>转换：</p>
<img src="/2022/06/24/ComputerSystemReview/image-20220624111549062.png" alt="image-20220624111549062" style="zoom: 50%;">

<p>进程状态转换 </p>
<ol>
<li><strong>运行态→等待态</strong>：等待使用资源或某事件发生， 如等待外设传输。</li>
<li><strong>等待态→就绪态</strong>：相应等待事件己经发生，如 外设传输结束。（等待结束） </li>
<li><strong>运行态→就绪态</strong>：时间片到或出现了更高优先 权进程。（落选） </li>
<li><strong>就绪态→运行态</strong>：进程被调度程序选中。</li>
</ol>
<p>了解</p>
<p><img src="/2022/06/24/ComputerSystemReview/image-20220624112059223.png" alt="image-20220624112059223"></p>
<p>进程的七状态模型，分为：创造、就绪、执行、堵塞、终止、挂起、就绪、挂起阻塞。</p>
<p>什么是挂起？这样细分状态有啥作用？</p>
<blockquote>
<p><strong>用户的请求</strong>：可能是在程序运行期间发现了可疑的问题，需要暂停进程。<br><strong>父进程的请求</strong>：考察，协调，或修改子进程。<br><strong>操作系统的需要</strong>：对运行中资源的使用情况进行检查和记账。<br><strong>负载调节的需要</strong>：有一些实时的任务非常重要，需要得到充足的内存空间，这个时候我们需要把非实时的任务进行挂起，优先使得实时任务执行。<br><strong>定时任务</strong>：一个进程可能会周期性的执行某个任务，那么在一次执行完毕后挂起而不是阻塞，这样可以节省内存。<br><strong>安全</strong>：系统有时可能会出现故障或者某些功能受到破坏，这是就需要将系统中正在进行的进程进行挂起，当系统故障消除以后，对进程的状态进行恢复。</p>
</blockquote>
<p>作用：考试可以填七个空？</p>
<h2 id="进程死锁的四个必要条件"><a href="#进程死锁的四个必要条件" class="headerlink" title="进程死锁的四个必要条件"></a>进程死锁的四个必要条件</h2><h3 id="死锁的定义"><a href="#死锁的定义" class="headerlink" title="死锁的定义"></a>死锁的定义</h3><blockquote>
<p>一组进程中，每个进程都无限等待被该组 进程中另一进程所占有的资源，因而永远无 法得到资源，这种现象称为进程死锁，这一 组进程就称为死锁进程。</p>
</blockquote>
<h3 id="经典IPC问题的两个实例-不要求掌握"><a href="#经典IPC问题的两个实例-不要求掌握" class="headerlink" title="经典IPC问题的两个实例(不要求掌握)"></a>经典IPC问题的两个实例(不要求掌握)</h3><h4 id="读者–写者问题"><a href="#读者–写者问题" class="headerlink" title="读者–写者问题"></a>读者–写者问题</h4><h4 id="哲学家就餐问题"><a href="#哲学家就餐问题" class="headerlink" title="哲学家就餐问题"></a>哲学家就餐问题</h4><h3 id="产生死锁的4个必要条件"><a href="#产生死锁的4个必要条件" class="headerlink" title="产生死锁的4个必要条件"></a>产生死锁的4个必要条件</h3><ol>
<li><strong>互斥条件</strong>。并发进程所要求和占有的 资源是不能同时被两个以上进程使用或操作 的，进程对它所需要的资源进行排他性控制。</li>
<li><strong>非剥夺（非抢占）条件</strong>。进程所获得 的资源在未使用完毕之前，不能被其他进程 强行剥夺，而只能由获得该资源的进程自己 释放。</li>
<li><strong>占有且等待条件</strong>。进程每次申请它所需 要的一部分资源，在等待新资源的同时继续 占用已分配到的资源。 </li>
<li><strong>环路条件</strong>。存在一种进程循环链，链中 每一个进程已获得的资源同时被下一个进程 所请求。 只要破坏其中一个条件，死锁就可防止。</li>
</ol>
<h2 id="安全状态的判断、银行家算法的概念"><a href="#安全状态的判断、银行家算法的概念" class="headerlink" title="安全状态的判断、银行家算法的概念"></a>安全状态的判断、银行家算法的概念</h2><p><strong>安全状态</strong></p>
<p>系统能按某种顺序, 如<code>&lt;P1, P2, …, Pn&gt;</code> 为每个进 程分配所需资源, 直到最大需求, 使每个进程都可顺 序完成, 称系统处于安全状态。（安全状态一定是没 有死锁发生的)</p>
<p><strong>银行家算法</strong></p>
<p>Dijkstra提出单资源银行家算法，银行家对客户提出下列约束条件： </p>
<p>① 客户必须预先说明所需最大资金量</p>
<p>② 银行给予分配的条件是银行所剩余额大于客户所需余额，否则拒绝</p>
<p>③ 银行满足了客户对资金的最大需求量，客户在资金运作后，应及时归还银行</p>
<p>例子：</p>
<p><img src="/2022/06/24/ComputerSystemReview/image-20220624113555335.png" alt="image-20220624113555335"></p>
<p>称 P2，P1，P3 为安全序列</p>
<p>一句话：把资源先给能满足他所有需求的，然后让他滚蛋，把他的所有的资源拿回来</p>
<h2 id="原语的概念"><a href="#原语的概念" class="headerlink" title="原语的概念"></a>原语的概念</h2><p>原语(Primitive) 原语是指在核心态下执行，且不允许被中断的一个过程，是一个原子操作，一个基本执行单位。</p>
<p>为什么我总觉得这个翻译这么sb 语从何处来？这tm和定义有毛线关系</p>
<p><img src="/2022/06/24/ComputerSystemReview/image-20220624114101242.png" alt="image-20220624114101242"></p>
<p>这才算正常翻译好吧 怪不得国内计算机这么lj  发展还不如台湾 连翻译都能翻译成这个shit的样子 还tm好意思出书？真的弱智 我tm一个大大的流汗黄豆</p>
<p><img src="/2022/06/24/ComputerSystemReview/image-20220624114459582.png" alt="image-20220624114459582"></p>
<p>基元（原语）的概念</p>
<p>原语是指在核心态下执行，且不允许被中断的一个过程，是一个原子操作，<strong>一个基本执行单位。</strong> </p>
<p>即：原语的执行是顺序的，不可并发。 另外，原语是一个过程，可能包括多条指 令代码，与机器指令有差别。</p>
<h2 id="进程调度基本算法-FCFS，RR，优先级-的思想"><a href="#进程调度基本算法-FCFS，RR，优先级-的思想" class="headerlink" title="进程调度基本算法[FCFS，RR，优先级]的思想"></a>进程调度基本算法[FCFS，RR，优先级]的思想</h2><h3 id="先来先服务（FCFS，First-Come-First-Serve-）"><a href="#先来先服务（FCFS，First-Come-First-Serve-）" class="headerlink" title="先来先服务（FCFS，First Come First  Serve ）"></a>先来先服务（FCFS，First Come First  Serve ）</h3><p>按作业进入后备队列的先后次序，先进入系统的作业优先被选中。 这是一种非剥夺式算法，易实现；但不利于短作业&amp;优待了长作业，可能使短作业周转时间变得很大。影响批作业的平均周转时间。适用于作业调度和进程调度。</p>
<p>在实际操作系统中，尽管很少单独使 用FCFS算法，但和其他一些算法配合 起来，FCFS算法在os中均有实现。 例如: 基于优先级的算法中对于相同 优先级的作业即采用FCFS方式。</p>
<h3 id="轮转法（RR，round-robin）"><a href="#轮转法（RR，round-robin）" class="headerlink" title="轮转法（RR，round robin）"></a>轮转法（RR，round robin）</h3><p>其思想是将CPU计算时间分成若干个时间间隔单位，即时间片。 每个进程每次最多执行1个时间片； 若时间片用完仍未结束，则让出CPU， 排到就绪队列尾部，等待下一次调度。</p>
<p>进程的时间片可以相等，也可以不相等。</p>
<p><img src="/2022/06/24/ComputerSystemReview/image-20220624120920676.png" alt="image-20220624120920676"></p>
<p>该算法仅适用于进程调度，不适用于作业调度。</p>
<blockquote>
<p>一句话：给所有人一定时间，干不完就滚到队伍最后去</p>
</blockquote>
<p>时间片大小的选取非常重要。</p>
<ul>
<li><p>若时间片过短，则调度次数增多， 进程切换次数增加，额外开销增大。 </p>
</li>
<li><p>若时间片过长，则降低了并发性， 甚至可能变成先来先服务法。</p>
</li>
</ul>
<p><strong>多级反馈轮转法</strong></p>
<p>其思想是将就绪进程分为多级，较高优先级的队列分配时间片较短。 调度先从高一级就绪队列中选择，同 一队列中按FCFS原则； 若不存在高优先级进程，则从较低一级的就绪队列中选择。</p>
<p>时间片用完而未完成的进程加入低一级就绪队列，但时间片加长。</p>
<h3 id="优先级法"><a href="#优先级法" class="headerlink" title="优先级法"></a>优先级法</h3><p>优先级法可用作作业/进程调度策略。 系统或用户按某种原则为作业或进程指定一个优先级，表示其优先权。 该算法的核心是确定进程或作业的优先级。确定优先级的方法可分为<strong>静态法和动态法</strong>。</p>
<h2 id="同步与互斥的概念，以及生产者-消费者模型的并发控制程序设计"><a href="#同步与互斥的概念，以及生产者-消费者模型的并发控制程序设计" class="headerlink" title="同步与互斥的概念，以及生产者-消费者模型的并发控制程序设计"></a>同步与互斥的概念，以及生产者-消费者模型的并发控制程序设计</h2><h3 id="临界资源与临界区"><a href="#临界资源与临界区" class="headerlink" title="临界资源与临界区"></a>临界资源与临界区</h3><p>临界资源：系统中同时只允许1个进程访问的资源称为临界资源或互斥资源。 </p>
<p>临界区：进程中涉及到临界资源的程序段称为临界区（critical region），即不允许多个并发进程交叉执行的一段程序。</p>
<h3 id="进程互斥"><a href="#进程互斥" class="headerlink" title="进程互斥"></a><strong>进程互斥</strong></h3><p>临界区的执行原则 </p>
<p>有空则进：当无进程执行临界区时，任何进程均可执行自己的临界区； </p>
<p>无空等待：不允许两个以上的进程同时执行临界区；其他进程必须等待； </p>
<p>有限等待：任何执行临界区代码的请求应在有限的时间内得到满足。</p>
<h3 id="P、V操作"><a href="#P、V操作" class="headerlink" title="P、V操作"></a>P、V操作</h3><blockquote>
<p>Dijkstra 发明了信号量和P、V 操作</p>
<p>使用一个整型变量来累计唤醒次数，称作信号量（semphore）</p>
<p>荷兰语中 尝试（Proberen）和增加或升高 （Verhogen）。 </p>
<p>利用信号量和P、V 操作既可以解决并发进程的竞争问题，又可以解决并发进程的协作问题。</p>
<p>P –down(sleep)  V – Up(wakeup)</p>
</blockquote>
<p>对一个信号量执行P操作，检查其值是否大于0。若该值大于0，则将其值减一(即用掉一个保存的唤醒信号)并继续；若该值为0，则进程将sleep，此时P操作并未结束。检查数值，修改变量值以及可能发生的睡眠操作均为一个单一的、不可分割的原子操作完成。<strong>保证一旦一个信号量操作开始，则在该操作完成或阻塞前，其他进程均不允许访问该信号量</strong>。这种原子性的操作对于解决同步问题和避免竞争条件是绝对必要的。</p>
<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">P(s)</span><br><span class="line">&#123;</span><br><span class="line">	s.value <span class="operator">=</span> s.value --<span class="comment">;</span></span><br><span class="line">	if (s.value &lt; <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			改当前进程状态为等待状态；</span><br><span class="line">			将其PCB插入相应等待队列末尾s.queue<span class="comment">;</span></span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>V操作对信号量的值增1。如果一个或多个进程在该信号量上睡眠，无法完成一个先前的V操作，则由系统选择一个（如随机挑选）并允许该进程完成他的V操作。</p>
<figure class="highlight wren"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">V</span>(<span class="params">s</span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="variable">s</span>.<span class="property">value</span> <span class="operator">=</span> <span class="variable">s</span>.<span class="property">value</span> <span class="operator">+</span><span class="operator">+</span>;</span><br><span class="line">	<span class="keyword">if</span> (<span class="variable">s</span>.<span class="property">value</span> <span class="operator">&lt;</span> <span class="operator">=</span> <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			唤醒等待队列<span class="variable">s</span>.<span class="property">queue</span>中的<span class="number">1</span>个进程；</span><br><span class="line">			改被唤醒进程的状态为就绪态；</span><br><span class="line">			并将其插入就绪队列；</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="用信号量解决生产者-消费者问题"><a href="#用信号量解决生产者-消费者问题" class="headerlink" title="用信号量解决生产者-消费者问题"></a>用信号量解决生产者-消费者问题</h3><p>为了确保信号量能正确工作，最重要的是要采用一种不可分割的方式来实现它。通常是将P，V操作作为系统调用实现。</p>
<ol>
<li>用PV 实现进程互斥步骤如下： </li>
<li>每个互斥资源设1个互斥变量Si信号量变量赋初始值Si=1</li>
<li>将各进程中的临界区代码段用P(Si)和V(Si)括起来，即可完成进程互斥<img src="/2022/06/24/ComputerSystemReview/image-20220624144507975.png" alt="image-20220624144507975"></li>
</ol>
<p>mutex即为信号量</p>
<p><img src="/2022/06/24/ComputerSystemReview/image-20220624173741835.png" alt="image-20220624173741835"></p>
<h3 id="进程同步概念"><a href="#进程同步概念" class="headerlink" title="进程同步概念"></a>进程同步概念</h3><p>指系统中多个进程中发生的事件存在某种时序关系，需要相互合作，共同完成一项任务。 具体说，<strong>一个进程运行到某一点时要求另 一伙伴进程为它提供消息，在未获得消息之 前，该进程处于等待状态，获得消息后被唤醒进入就绪态</strong>。</p>
<h3 id="用PV操作实现进程同步"><a href="#用PV操作实现进程同步" class="headerlink" title="用PV操作实现进程同步"></a>用PV操作实现进程同步</h3><p>具体步骤分为三步： </p>
<p>① 为各并发进程设置各自的私用信号量</p>
<p>② 信号量变量赋初值 </p>
<p>③ 利用ＰＶ原语和信号量规定各进程的<strong>执行顺序</strong></p>
<p><img src="/2022/06/24/ComputerSystemReview/image-20220624144803020.png" alt="image-20220624144803020"></p>
<p><strong>用full和empty来保证某种事件的发生顺序或不发生</strong>来实现同步 来看一个例题</p>
<p>某银行提供一个服务窗口和10个供顾客等待的座位。顾客到达银行时，若有空座位，则到取号机上领取一个号，等待叫号。取号机每次仅允许一个顾客使用。当营业员空闲时，通过叫号选取一位顾客，并为其服务。顾客及营业员的活动描述如下：</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">cobegin</span><br><span class="line">&#123; </span><br><span class="line">process 顾客</span><br><span class="line">&#123;</span><br><span class="line">	从取号机获取一个号码；</span><br><span class="line">	等待叫号；</span><br><span class="line">	获得服务；</span><br><span class="line">&#125;</span><br><span class="line">process 营业员</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">while</span>（TRUE）</span><br><span class="line">		&#123;</span><br><span class="line">			叫号；</span><br><span class="line">			为顾客服务；</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;coend</span><br></pre></td></tr></table></figure>

<p>请添加必要的信号量和P、V（或wait（）、signal（））操作，实现上述过程中的互斥与同步。要求写出完整的过程，说明信号量的含义并赋初值。</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">semaphore mutex=<span class="number">1</span>;   <span class="comment">//互斥使用取号机 互斥锁 实现取号的互斥问题</span></span><br><span class="line">semaphore empty=<span class="number">10</span>;     <span class="comment">//空座位的数量	</span></span><br><span class="line">semaphore full=<span class="number">0</span>;     <span class="comment">//已占座位的数量，必须大于0营业员才可以开始服务</span></span><br><span class="line">semaphore service=<span class="number">0</span>;        <span class="comment">//等待叫号</span></span><br><span class="line">cobegin</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">process 顾客i&#123;</span><br><span class="line">	<span class="constructor">P(<span class="params">empty</span>)</span>;	<span class="comment">//申请座位 成功则将空座位减一</span></span><br><span class="line">    <span class="constructor">P(<span class="params">mutex</span>)</span>;    <span class="comment">//进入临界区 准备取号</span></span><br><span class="line">	从取号机获得一个号;</span><br><span class="line">	<span class="constructor">V(<span class="params">mutex</span>)</span>;   <span class="comment">//离开临界区 取完了号</span></span><br><span class="line">	<span class="constructor">V(<span class="params">full</span>)</span>;     <span class="comment">//将空座位加1</span></span><br><span class="line">	<span class="constructor">P(<span class="params">service</span>)</span>;           <span class="comment">// 等待叫号</span></span><br><span class="line">	等待叫号；</span><br><span class="line">&#125;</span><br><span class="line">process 营业员&#123;</span><br><span class="line"><span class="keyword">while</span>(TRUE)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="constructor">P(<span class="params">full</span>)</span>; <span class="comment">//营业员面前没人就P</span></span><br><span class="line">		叫号； </span><br><span class="line">		<span class="constructor">V(<span class="params">empty</span>)</span>; <span class="comment">// 叫完号才能开放一个空位  </span></span><br><span class="line">		为顾客服务;		  	   		 </span><br><span class="line">		<span class="constructor">V(<span class="params">service</span>)</span>;          <span class="comment">//叫下一个号</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">coend</span><br></pre></td></tr></table></figure>

<p>看了网上很多 感觉都不太对 自己写了一个 也不知道对不对。。。应该对一点点</p>
<h2 id="存储管理中重定位的概念及其方式"><a href="#存储管理中重定位的概念及其方式" class="headerlink" title="存储管理中重定位的概念及其方式"></a>存储管理中重定位的概念及其方式</h2><h3 id="逻辑地址（虚拟地址）"><a href="#逻辑地址（虚拟地址）" class="headerlink" title="逻辑地址（虚拟地址）"></a>逻辑地址（虚拟地址）</h3><p>目标程序中的地址是<strong>一个从0开始的地址</strong>， 并不是内存的实际地址。 把用户目标程序使用的地址称为逻辑地址 （虚拟地址）。 一个用户作业的目标程序的逻辑地址集合称为该作业的逻辑地址空间。</p>
<p>程序的逻辑地址空间<strong>可以是一维的</strong>，这时逻辑地址即为从0 开始顺序递增的一个地址序列。 逻辑地址<strong>也可以是二维（多维）的</strong>，即程序中的地址是不连续的。</p>
<h3 id="物理地址（绝对地址）"><a href="#物理地址（绝对地址）" class="headerlink" title="物理地址（绝对地址）"></a>物理地址（绝对地址）</h3><p>我们把主存中的实际存储单元称为物理地址（绝对地址），物理地址的总体相应构成了用户程序实际运行的物理地址空间。 操作系统将内存分为<strong>系统区和用户区</strong>两个部分。</p>
<h3 id="逻辑地址与物理地址的关系"><a href="#逻辑地址与物理地址的关系" class="headerlink" title="逻辑地址与物理地址的关系"></a>逻辑地址与物理地址的关系</h3><p>某个当程序运行时，操作系统则分配一些 地址空间，此时程序和数据的实际地址与原来程序中的逻辑地址并非是一致的。 CPU访问地址的只能是物理地址，因此， 逻辑地址必须转换成正确的物理地址！ </p>
<p>一句话</p>
<blockquote>
<p>物理地址=逻辑地址+分区起始地址</p>
</blockquote>
<h3 id="地址变换"><a href="#地址变换" class="headerlink" title="地址变换"></a>地址变换</h3><p>memory map 把程序中逻辑地址转换为物理地址的工作 称为地址转换或<strong>地址重定位、地址映射</strong>。 </p>
<p>静态重定位：发生在作业执行前一次完成，多由软件独立完成</p>
<p>动态重定位：发生在程序执行过程中，通常借助于地址转换机构硬件与软件共同实现。</p>
<p>就一个简单的偏移关系 啥都没有</p>
<p><img src="/2022/06/24/ComputerSystemReview/image-20220624155406128.png" alt="image-20220624155406128"></p>
<h2 id="请求页式管理的地址重定位过程（计算）未总结完"><a href="#请求页式管理的地址重定位过程（计算）未总结完" class="headerlink" title="请求页式管理的地址重定位过程（计算）未总结完"></a>请求页式管理的地址重定位过程（计算）未总结完</h2><h3 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h3><p>基本思想：</p>
<p>每个程序拥有自己的地址空间，这个空间被分割成很多块，每一块称作一页或页面。每一页拥有自己的地址空间。</p>
<h3 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h3><p>大部分虚拟内存系统中都使用一种成为分页（paging）的技术。在使用虚拟内存的情况下，虚拟地址不是直接送到内存总线上，而是被送到内存管理元（MMU），MMU把虚拟地址映射为物理内存地址。</p>
<h3 id="页框"><a href="#页框" class="headerlink" title="页框"></a>页框</h3><p>把虚拟地址空间按照固定大小大小划分成被称为页面的若干单元，在<strong>物理内存中对应的单元成为页框</strong>。</p>
<h3 id="页表"><a href="#页表" class="headerlink" title="页表"></a>页表</h3><p>虚拟地址到物理地址的映射可以概括如下：虚拟地址被分为<strong>虚拟页号</strong>（高位部分）和<strong>偏移量</strong>（低位部分）两部分。</p>
<p>虚拟页号可用作页表的索引，以找到该虚拟页面对应的页表项。有页表项可以找到页框号（如果有的话）。然后把页框号拼接到偏移量的高位端，以替换掉虚拟页号，形成送往内存的物理地址。</p>
<p>页表的目的是把虚拟页面映射成页框。从数学角度说，也表示一个函数，它的参数是虚拟页号，结果是物理页号。</p>
<h3 id="计算"><a href="#计算" class="headerlink" title="计算"></a>计算</h3><p>虽然不觉得这种计算有任何的意义</p>
<p><img src="/2022/06/24/ComputerSystemReview/image-20220624162641093.png" alt="image-20220624162641093"></p>
<p>存储页框表：</p>
<p>即物理内存分配情况，包括空闲页框位置、空闲页框总数等，整个系统1张存储页框表。 实现形式有位示图和空闲链表。 </p>
<p>位示图：包含若干个字，每个字包含若干位，每位对应1个页框。1分配，0空闲。</p>
<p><img src="/2022/06/24/ComputerSystemReview/image-20220624162912940.png" alt="image-20220624162912940"></p>
<p>这里应该是打错了 应该是<strong>页框号</strong></p>
<p>地址变换</p>
<blockquote>
<p>物理地址=页框号*页大小+页内地址</p>
</blockquote>
<p><img src="/2022/06/24/ComputerSystemReview/image-20220624163532078.png" alt="image-20220624163532078"></p>
<p>PS:这里应该叫虚拟地址空间</p>
<p><img src="/2022/06/24/ComputerSystemReview/format,png-16560607633459.png" alt="内存映射"></p>
<h3 id="虚拟-请求-页式管理"><a href="#虚拟-请求-页式管理" class="headerlink" title="虚拟(请求)页式管理"></a>虚拟(请求)页式管理</h3><p><strong>引入原因</strong> </p>
<ul>
<li><p>程序大于内存</p>
</li>
<li><p>程序暂时不执行或运行完是否还要占用内存</p>
</li>
</ul>
<p><strong>基本原理</strong> </p>
<p>系统把程序当前使用部分保留在内存，而把其它部分保存在磁盘上，在需要时在内存和磁盘之间动态交换。</p>
<p>不足：以时间换空间！</p>
<h2 id="存储管理中碎片的概念，及不同存储管理方法出现的碎片问题"><a href="#存储管理中碎片的概念，及不同存储管理方法出现的碎片问题" class="headerlink" title="存储管理中碎片的概念，及不同存储管理方法出现的碎片问题"></a>存储管理中碎片的概念，及不同存储管理方法出现的碎片问题</h2><h3 id="碎片"><a href="#碎片" class="headerlink" title="碎片"></a>碎片</h3><p>这部分做大作业时应该就已经讲过了。。。</p>
<p><strong>不能被有效利用的空闲部分称为碎片。</strong></p>
<p><strong>内部碎片</strong>：在已分配区域中，未被有效利用的部分。 </p>
<p><strong>外部碎片</strong>：它本身是一个空闲区，但由于容量较小，实际上不能被再次分配。</p>
<p><strong>碎片问题解决</strong> </p>
<p>紧凑技术：通过在内存移动程序，将所有小的空闲区域合并为大的空闲区域 （也称：紧缩技术，浮动技术，移动技术）</p>
<p>问题：开销大</p>
<p>例题</p>
<img src="/2022/06/24/ComputerSystemReview/image-20220624164041655.png" alt="image-20220624164041655" style="zoom:67%;">

<p>内存管理主要包括：连续内存管理、分页、分段。</p>
<p>突然发现自己不会。。。</p>
<blockquote>
<p>内部碎片就是为每个进程分布的内存空间之中所没有被使用到的内存碎片。通常出现在分页式存储管理之中。分页式是什么应该很好理解，就是把内存按照分为一页页大小相同的页面，然后再把这些页面分配给进程。因此，在分配给进程时可能会出现这样的情况：<br>进程需要3MB，分给他4页，每页1MB，这样4&gt;3，就会造成1MB的内部碎片。<br>而分段式存储管理为什么不会产生内部碎片？</p>
<p>归根结底是由分段本身的定义出发的。如果说分页式是系统对内存的分割，那么分段式就是用户对程序数据的分割。<br>分页式是没有任何逻辑意义的，而分段式是有其意义在的。<br>比如说一个程序有主程序段Main类，有通用库，有数据段，这样我们就把这个程序分为三段，分别对应Main，库，数据（说的是最浅显的，详细的可以百度其他），是有逻辑意义的独立单位。都这样分了，怎么还会出现内部碎片？反之，如果是分页式，就可能出现Main类横跨两页，且整个程序装入内存后还有碎片空间的可能了。<br>总之，引入分段式存储管理本就在一定程度上解决了内部碎片，并且满足了用户的需求。但是分段式存储管理也有不足之处，内存利用率变低了。<br>因此又引入之后的段页式存储管理方式。</p>
</blockquote>
<p>见下个章节</p>
<h2 id="段页式存储管理的数据结构及重定位过程（概念）"><a href="#段页式存储管理的数据结构及重定位过程（概念）" class="headerlink" title="段页式存储管理的数据结构及重定位过程（概念）"></a>段页式存储管理的数据结构及重定位过程（概念）</h2><h3 id="内存分段"><a href="#内存分段" class="headerlink" title="内存分段"></a>内存分段</h3><p>程序是由若干个逻辑分段组成的，如可由代码分段、数据分段、栈段、堆段组成。<strong>不同的段是有不同的属性的，所以就用分段（Segmentation）的形式把这些段分离出来。</strong></p>
<p>分段机制下，虚拟地址和物理地址是如何映射的？</p>
<img src="/2022/06/24/ComputerSystemReview/format,png.png" alt="内存分段-寻址的方式" style="zoom: 50%;">

<ul>
<li><strong>段选择子</strong>就保存在段寄存器里面。段选择子里面最重要的是<strong>段号</strong>，用作段表的索引。<strong>段表</strong>里面保存的是这个<strong>段的基地址、段的界限和特权等级</strong>等。</li>
<li>虚拟地址中的<strong>段内偏移量</strong>应该位于 0 和段界限之间，如果段内偏移量是合法的，就将段基地址加上段内偏移量得到物理内存地址。</li>
</ul>
<p>在上面，知道了虚拟地址是通过<strong>段表</strong>与物理地址进行映射的，分段机制会把程序的虚拟地址分成 4 个段，每个段在段表中有一个项，在这一项找到段的基地址，再加上偏移量，于是就能找到物理内存中的地址，如下图：</p>
<p><img src="/2022/06/24/ComputerSystemReview/format,png-16560603644473.png" alt="内存分段-虚拟地址与物理地址"></p>
<p>如果要访问段 3 中偏移量 500 的虚拟地址，我们可以计算出物理地址为，段 3 基地址 7000 + 偏移量 500 = 7500。</p>
<p>分段的办法很好，解决了程序本身不需要关心具体的物理内存地址的问题，但它也有一些不足之处：</p>
<p>第一个就是内存碎片的问题。<br>第二个就是内存交换的效率低的问题。</p>
<p><strong>分段为什么会产生内存碎片的问题？</strong></p>
<p>我们来看看这样一个例子。假设有 1G 的物理内存，用户执行了多个程序，其中：</p>
<p>游戏占用了 512MB 内存<br>浏览器占用了 128MB 内存<br>音乐占用了 256 MB 内存。<br>这个时候，如果我们关闭了浏览器，则空闲内存还有 1024 - 512 - 256 = 256MB。</p>
<p>如果这个 256MB 不是连续的，被分成了两段 128 MB 内存，这就会导致没有空间再打开一个 200MB 的程序<br><img src="/2022/06/24/ComputerSystemReview/format,png-16560604573506.png" alt="内存碎片的问题" style="zoom:50%;"></p>
<p>这里的内存碎片的问题共有两处地方：</p>
<blockquote>
<p>外部内存碎片，也就是产生了多个不连续的小物理内存，导致新的程序无法被装载；<br>内部内存碎片，程序所有的内存都被装载到了物理内存，但是这个程序有部分的内存可能并</p>
</blockquote>
<p>不是很常使用，这也会导致内存的浪费；<br>针对上面两种内存碎片的问题，解决的方式会有所不同。</p>
<p>解决外部内存碎片的问题就是内存交换。</p>
<p>可以把音乐程序占用的那 256MB 内存写到硬盘上，然后再从硬盘上读回来到内存里。不过再读回的时候，我们不能装载回原来的位置，而是紧紧跟着那已经被占用了的 512MB 内存后面。这样就能空缺出连续的 256MB 空间，于是新的 200MB 程序就可以装载进来。</p>
<p>这个内存交换空间，在 Linux 系统里，也就是我们常看到的 Swap 空间，这块空间是从硬盘划分出来的，用于内存与硬盘的空间交换。</p>
<p><strong>再来看看，分段为什么会导致内存交换效率低的问题？</strong></p>
<p>对于多进程的系统来说，用分段的方式，内存碎片是很容易产生的，产生了内存碎片，那不得不重新 Swap 内存区域，这个过程会产生性能瓶颈。</p>
<p>因为硬盘的访问速度要比内存慢太多了，每一次内存交换，我们都需要把一大段连续的内存数据写到硬盘上。</p>
<p>所以，如果内存交换的时候，交换的是一个占内存空间很大的程序，这样整个机器都会显得卡顿。</p>
<p>为了解决内存分段的内存碎片和内存交换效率低的问题，就出现了内存分页。</p>
<h3 id="段页式内存管理"><a href="#段页式内存管理" class="headerlink" title="段页式内存管理"></a>段页式内存管理</h3><p>内存分段和内存分页并不是对立的，它们是可以组合起来在同一个系统中使用的，那么组合起来后，通常称为<strong>段页式内存管理</strong>。</p>
<p><img src="/2022/06/24/ComputerSystemReview/format,png-165606084954512.png" alt="段页式地址空间"></p>
<p>段页式内存管理实现的方式：</p>
<p>先将程序划分为多个有逻辑意义的段，也就是前面提到的分段机制；<br>接着再把每个段划分为多个页，也就是对分段划分出来的连续空间，再划分固定大小的页；<br>这样，地址结构就由段号、段内页号和页内位移三部分组成。</p>
<p>用于段页式地址变换的数据结构是每一个程序一张段表，每个段又建立一张页表，段表中的地址是页表的起始地址，而页表中的地址则为某页的物理页号，如图所示：<br><img src="/2022/06/24/ComputerSystemReview/format,png-165606086771215.png" alt="段页式管理中的段表、页表与内存的关系"></p>
<p>段页式地址变换中要得到物理地址须经过三次内存访问：</p>
<ul>
<li>第一次访问段表，得到页表起始地址；</li>
<li>第二次访问页表，得到物理页号；</li>
<li>第三次将物理页号与页内位移组合，得到物理地址。</li>
</ul>
<p>可用软、硬件相结合的方法实现段页式地址变换，这样虽然增加了硬件成本和系统开销，但提高了内存的利用率。</p>
<h3 id="Linux-内存管理"><a href="#Linux-内存管理" class="headerlink" title="Linux 内存管理"></a>Linux 内存管理</h3><p>那么，Linux 操作系统采用了哪种方式来管理内存呢？</p>
<p>在回答这个问题前，我们得先看看 Intel 处理器的发展历史。</p>
<p>早期 Intel 的处理器从 80286 开始使用的是段式内存管理。但是很快发现，光有段式内存管理而没有页式内存管理是不够的，这会使它的 X86 系列会失去市场的竞争力。因此，在不久以后的 80386 中就实现了对页式内存管理。也就是说，80386 除了完成并完善从 80286 开始的段式内存管理的同时还实现了页式内存管理。</p>
<p>但是这个 80386 的页式内存管理设计时，没有绕开段式内存管理，而是建立在段式内存管理的基础上，这就意味着，页式内存管理的作用是在由段式内存管理所映射而成的地址上再加上一层地址映射。</p>
<p>由于此时由段式内存管理映射而成的地址不再是“物理地址”了，Intel 就称之为“线性地址”（也称虚拟地址）。于是，段式内存管理先将逻辑地址映射成线性地址，然后再由页式内存管理将线性地址映射成物理地址。</p>
<p><img src="/2022/06/24/ComputerSystemReview/format,png-165606094777021.png" alt="Intel X86 逻辑地址解析过程"></p>
<p><img src="/2022/06/24/ComputerSystemReview/format,png-165606093371718.png" alt="img"></p>
<p>这里说明下逻辑地址和线性地址：</p>
<p>程序所使用的地址，通常是没被段式内存管理映射的地址，称为逻辑地址；<br>通过段式内存管理映射的地址，称为线性地址，也叫虚拟地址；<br>逻辑地址是「段式内存管理」转换前的地址，线性地址则是「页式内存管理」转换前的地址。</p>
<p>了解完 Intel 处理器的发展历史后，我们再来说说 Linux 采用了什么方式管理内存？</p>
<p>Linux 内存主要采用的是页式内存管理，但同时也不可避免地涉及了段机制。</p>
<p>这主要是上面 Intel 处理器发展历史导致的，因为 Intel X86 CPU 一律对程序中使用的地址先进行段式映射，然后才能进行页式映射。既然 CPU 的硬件结构是这样，Linux 内核也只好服从 Intel 的选择。</p>
<p>但是事实上，Linux 内核所采取的办法是使段式映射的过程实际上不起什么作用。也就是说，“上有政策，下有对策”，若惹不起就躲着走。</p>
<p>Linux 系统中的每个段都是从 0 地址开始的整个 4GB 虚拟空间（32 位环境下），也就是所有的段的起始地址都是一样的。这意味着，Linux 系统中的代码，包括操作系统本身的代码和应用程序代码，所面对的地址空间都是线性地址空间（虚拟地址），这种做法相当于屏蔽了处理器中的逻辑地址概念，段只被用于访问控制和内存保护。</p>
<p>我们再来瞧一瞧，Linux 的虚拟地址空间是如何分布的？</p>
<p>在 Linux 操作系统中，虚拟地址空间的内部又被分为内核空间和用户空间两部分，不同位数的系统，地址空间的范围也不同。比如最常见的 32 位和 64 位系统，如下所示：</p>
<img src="/2022/06/24/ComputerSystemReview/format,png-165606095883624.png" alt="用户空间与内存空间" style="zoom:67%;">

<p>通过这里可以看出：</p>
<p>32 位系统的内核空间占用 1G，位于最高处，剩下的 3G 是用户空间；<br>64 位系统的内核空间和用户空间都是 128T，分别占据整个内存空间的最高和最低处，剩下的中间部分是未定义的。<br>再来说说，内核空间与用户空间的区别：</p>
<p>进程在用户态时，只能访问用户空间内存；<br>只有进入内核态后，才可以访问内核空间的内存；<br>虽然每个进程都各自有独立的虚拟内存，但是每个虚拟内存中的内核地址，其实关联的都是相同的物理内存。这样，进程切换到内核态后，就可以很方便地访问内核空间内存。</p>
<img src="/2022/06/24/ComputerSystemReview/format,png-165606096579827.png" alt="每个进程的内核空间都是一致的" style="zoom:67%;">

<p>接下来，进一步了解虚拟空间的划分情况，用户空间和内核空间划分的方式是不同的，内核空间的分布情况就不多说了。</p>
<p>我们看看用户空间分布的情况，以 32 位系统为例，我画了一张图来表示它们的关系：</p>
<img src="/2022/06/24/ComputerSystemReview/format,png-165606097362530.png" alt="虚拟内存空间划分" style="zoom:67%;">

<p>通过这张图你可以看到，用户空间内存，从低到高分别是 7 种不同的内存段：</p>
<p>程序文件段，包括二进制可执行代码；<br>已初始化数据段，包括静态常量；<br>未初始化数据段，包括未初始化的静态变量；<br>堆段，包括动态分配的内存，从低地址开始向上增长；<br>文件映射段，包括动态库、共享内存等，从低地址开始向上增长（跟硬件和内核版本有关）；<br>栈段，包括局部变量和函数调用的上下文等。栈的大小是固定的，一般是 8 MB。当然系统也提供了参数，以便我们自定义大小；<br>在这 7 个内存段中，堆和文件映射段的内存是动态分配的。比如说，使用 C 标准库的 malloc() 或者 mmap() ，就可以分别在堆和文件映射段动态分配内存。</p>
<h2 id="页框调度的概念，抖动现象及其可能的因素"><a href="#页框调度的概念，抖动现象及其可能的因素" class="headerlink" title="页框调度的概念，抖动现象及其可能的因素"></a>页框调度的概念，抖动现象及其可能的因素</h2><h3 id="页框置换算法（页框调度）"><a href="#页框置换算法（页框调度）" class="headerlink" title="页框置换算法（页框调度）"></a>页框置换算法（页框调度）</h3><p>置换算法选出一个合适的页（框）淘汰。 </p>
<p>（1）最佳页框算法（OPT） 淘汰后不再需要的或最远的将来才会用到 的页。难实现 </p>
<p>（2）先进先出算法（FIFO） 选择内存中驻留时间最长的页淘汰，访问 位保存页的装入时间。简单，效率低</p>
<p>（3）最近最久未用算法（LRU） 选择最后一次访问时间距离当前最久的页 淘汰，即淘汰最长时间没有使用的页。 访问位保存最近访问的时间。局部原理</p>
<h3 id="颠簸（抖动）："><a href="#颠簸（抖动）：" class="headerlink" title="颠簸（抖动）："></a>颠簸（抖动）：</h3><p>在虚拟存储系统中，由于过量的页框调度， 系统难以有效工作，系统效率急剧下降，该 现象称为颠簸或抖动（Thrashing）。 </p>
<p>原因： </p>
<ul>
<li><p>页框淘汰算法不合理</p>
</li>
<li><p>分配给进程的物理页框数太少；</p>
</li>
</ul>
<h2 id="文件逻辑结构、文件物理结构的概念及分类（特点）"><a href="#文件逻辑结构、文件物理结构的概念及分类（特点）" class="headerlink" title="文件逻辑结构、文件物理结构的概念及分类（特点）"></a>文件逻辑结构、文件物理结构的概念及分类（特点）</h2><h3 id="逻辑结构（逻辑文件）"><a href="#逻辑结构（逻辑文件）" class="headerlink" title="逻辑结构（逻辑文件）"></a>逻辑结构（逻辑文件）</h3><p>文件的逻辑结构和组织是从用户观点出发， 研究用户概念中的信息组织方式。 文件的逻辑结构分两种形式：一种是<strong>流式文件</strong>，另一种是<strong>记录式文件</strong>。</p>
<p>流式文件指：</p>
<p>文件内的数据不再分单位， 只是一串信息序列集合，即是无结构的 文件。 这种文件常常按长度来读取所需信息， 也可用插入的特殊字符作为分界。</p>
<p>记录式文件：</p>
<p>是一种有结构的文件，它由若干逻辑记录组成。 逻辑记录是文件中按信息在逻辑上的独立含 意划分的一个信息单位，记录在文件中的排列可能有一定顺序关系</p>
<blockquote>
<p>？？？为什么和网上的不一样 有用的不交 净在这整些花里胡哨的</p>
</blockquote>
<h3 id="物理结构（物理文件）"><a href="#物理结构（物理文件）" class="headerlink" title="物理结构（物理文件）"></a>物理结构（物理文件）</h3><p>文件的物理结构是指文件在存储设备上的存 放方法和形态。 存储空间常被划分为若干个大小相等的物理 块。文件信息也划分为等大的逻辑块。 文件的访问以块作为分配和传送信息的基本单位。</p>
<p>(1) 连续文件 </p>
<p>连续文件是把逻辑上连续的文件信息顺序 地存储到连续物理块中。 优点：已知起址和长度即可访问；顺序存取 效率高。 不足：难以动态增长；可能存在较多零头。 因此，该类文件比较适宜存储备份性文件。</p>
<p>(2) 链接文件 </p>
<p>链接文件结构用非连续的物理块来存放文件 信息，通过指针链接在一起。 优点：只需指明第1个块号即可访问；易于动 态增长。 缺点：只能顺序访问，效率较低。 因此，链接文件结构不适宜随机存取。</p>
<p>(3) 索引文件</p>
<p>系统为每个文件建立1张索引表，保存文件 的逻辑块号和物理块号的对应关系。类似于页 表。 文件说明信息项给出文件索引表的物理地址。 索引文件结构既可以满足动态增长，也可进 行随机存取。</p>
<h2 id="I-O-控制方式的类型及特点"><a href="#I-O-控制方式的类型及特点" class="headerlink" title="I/O 控制方式的类型及特点"></a>I/O 控制方式的类型及特点</h2><p>外围设备和内存之间的常用数据传送控制方式有4种。即：</p>
<h3 id="1-程序直接控制方式"><a href="#1-程序直接控制方式" class="headerlink" title="(1) 程序直接控制方式"></a><strong>(1) 程序直接控制方式</strong></h3><p>由用户进程来直接控制内存或CPU和外围设备之间的信息传送。 当用户进程需要传输数据时，它通过CPU 发出启动设备命令，然后，用户进程进入测试等待状态，直到相应设备空闲，且准备好， 即开始传输数据</p>
<p>优点：控制简单，不需要多少硬件支持； </p>
<p>缺点： </p>
<p>（1）CPU和外围设备串行工作，CPU利用率低； </p>
<p>（2）CPU只能和一台外围设备交换数据信息，从 而不能实现设备之间的并行工作； </p>
<p>（3）由于程序直接控制方式依靠测试设备标志触 发器的状态位来控制数据传送，因此无法发现和处 理由于设备或其他硬件所产生的错误。 因此，该方式只适用于CPU速度慢，外围设备较 少的系统。</p>
<h3 id="2-中断控制方式"><a href="#2-中断控制方式" class="headerlink" title="**(2) 中断控制方式 **"></a>**(2) 中断控制方式 **</h3><p>这种方式要求CPU与设备(或控制器)之间 有相应的中断请求线，且在设备控制器的控 制状态寄存器中保存中断允许位。 基本步骤：</p>
<p>​    (1) 进程通过CPU发出启动外围设备准备 数据指令，同时将中断允许位置1。</p>
<p>​    (2) 在进程发出指令启动设备之后，该进程 放弃处理机，等待输入完成。</p>
<p>​    (3) 当输入完成时，I/O控制器通过中断请 求线向CPU发出中断信号。 </p>
<p>​    (4) CPU在接收到中断信号之后，转向中 断处理程序将被中断进程状态设置为就绪。 </p>
<p>​    (5) 进程调度选中该进程后，该进程即从约 定的内存单元中取出数据继续工作。</p>
<p>优点：中断方式支持多道程序和设备的并行 操作，提高CPU利用率； </p>
<p>缺点： </p>
<p>1）中断发生在I/O设备数据缓冲器装满数 据时，而数据缓冲器通常较小，因此，一次 数据传送发生中断次数较多，将耗去大量 CPU处理时间。</p>
<p>2）如果很多设备通过中断处理方式进行 并行操作，则OS可能由于中断次数急剧增加 而造成CPU无法响应中断和出现数据丢失现 象。 </p>
<p>3）如果外围设备速度较高，可能造成数据缓冲器的数据由于CPU来不及取走而丢失。</p>
<h3 id="3-DMA方式（Direct-Memory-Access）"><a href="#3-DMA方式（Direct-Memory-Access）" class="headerlink" title="(3) DMA方式（Direct Memory Access）"></a><strong>(3) DMA方式（Direct Memory Access）</strong></h3><p>即直接存取方式。基本思想是在外围设备和内存 之间开辟直接的数据交换通路。 在DMA方式中，DMA控制器具有比中断方式和程 序直接控制方式时更强的功能。 </p>
<p>DMA方式采用窃取或挪用系统的总线控制权把数 据直接送到内存。 </p>
<p>即，DMA控制器可用来代替CPU控制内存和设 备之间进行成批的数据交换。</p>
<p>优点：减少了中断次数，DMA控制器与CPU并行， 避免了设备缓冲器中的数据丢失问题； 缺点： </p>
<p>1）DMA方式对外围设备的管理和某些操作仍 由CPU控制。 </p>
<p>2）功能较简单，不能满足复杂的I/O 要求。 因此，大中型计算机系统中除了设置DMA器件， 还设置专门的硬件装置—通道。</p>
<h3 id="4-通道方式"><a href="#4-通道方式" class="headerlink" title="(4) 通道方式"></a><strong>(4) 通道方式</strong></h3><p>1）<strong>字节多路通道</strong>。连接大量慢速外围设备，如 软盘机、纸带机、卡片机等。以字节为单位交叉 地为多个设备轮流服务。 </p>
<p>2）<strong>选择通道</strong>。它用于连接高速磁带机和磁盘机 等设备。选择通道在一段时间内只能执行一个通 道程序，一台设备传输完成后再选择另一设备。</p>
<p>3）<strong>数组多路通道</strong>。对于磁盘类似设备，虽然传 输时间短，但移臂定位时间长，则使用选择通道在 移臂时间内，通道只能空等。 数组多路通道则先为一台设备执行一条通道命令， 然后再为另一台设备执行一条通道命令。 对于若干台磁盘机，可以按次序交叉传输一批批 信息，这样就避免了移臂操作过长地占用通道。 该技术实质是：对通道程序采用多道程序设计技 术的硬件实现。</p>

    </div>

    
    
    

    <footer class="post-footer">
          

<div class="post-copyright">
<ul>
  <li class="post-copyright-author">
      <strong>Post author:  </strong>b1ue0cean
  </li>
  <li class="post-copyright-link">
      <strong>Post link: </strong>
      <a href="http://example.com/2022/06/24/ComputerSystemReview/" title="操作系统期末复习">http://example.com/2022/06/24/ComputerSystemReview/</a>
  </li>
  <li class="post-copyright-license">
    <strong>Copyright Notice:  </strong>All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> unless stating additionally.
  </li>
</ul>
</div>

          <div class="followme">
  <span>Welcome to my other publishing channels</span>

  <div class="social-list">

      <div class="social-item">
        <a target="_blank" class="social-link" href="https://twitter.com/b1ue0cean7">
          <span class="icon">
            <i class="fab fa-twitter"></i>
          </span>

          <span class="label">Twitter</span>
        </a>
      </div>

      <div class="social-item">
        <a target="_blank" class="social-link" href="/atom.xml">
          <span class="icon">
            <i class=""></i>
          </span>

          <span class="label">RSS</span>
        </a>
      </div>
  </div>
</div>

          <div class="post-tags">
              <a href="/tags/review/" rel="tag"># review</a>
              <a href="/tags/Computer-System/" rel="tag"># Computer System</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2022/06/23/Format-String/" rel="prev" title="格式化字符串学习">
                  <i class="fa fa-chevron-left"></i> 格式化字符串学习
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2022/06/24/RaceCondition/" rel="next" title="Race Condition">
                  Race Condition <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






    <div class="comments gitalk-container"></div>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  
<script src="https://cdn.jsdelivr.net/npm/hexo-generator-searchdb@1.4.0/dist/search.js" integrity="sha256-vXZMYLEqsROAXkEw93GGIvaB2ab+QW6w3+1ahD9nXXA=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>





  




<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1.7.2/dist/gitalk.css" integrity="sha256-AJnUHL7dBv6PGaeyPQJcgQPDjt/Hn/PvYZde1iqfp8U=" crossorigin="anonymous">

<script class="next-config" data-name="gitalk" type="application/json">{"enable":true,"github_id":"godrun666","repo":"godrun666.github.io","client_id":"7f8a0f5a5c88a0fea952","client_secret":"57250fa3a3b4cb1d0e0dad43bb1fffe7355d61a8","admin_user":"godrun666","distraction_free_mode":true,"proxy":"https://cors-anywhere.azm.workers.dev/https://github.com/login/oauth/access_token","language":null,"js":{"url":"https://cdn.jsdelivr.net/npm/gitalk@1.7.2/dist/gitalk.min.js","integrity":"sha256-Pmj85ojLaPOWwRtlMJwmezB/Qg8BzvJp5eTzvXaYAfA="},"path_md5":"6646fef4d704358ac62e493e818617d7"}</script>
<script src="/js/third-party/comments/gitalk.js"></script>

</body>
</html>
